---
title: leetcode史上最屌解法
date: 2020-04-24 00:45:03
tags:
---


大家好，今天我们一起做[Leetcode第877题](https://leetcode.com/problems/maximal-square/)多人运动...啊不是，是正经的双人运动。这是一道难度为Medium的题目。这道题可以算得上是leetcode最令人“虎躯一震”的题目之一了，堪称leetcode史上最屌的解法。

## 题目描述

题目大意如下所描述：我们有一对好基友Alex和Lee在玩双人♂游戏，游戏规则如下所述：

```markdown
亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

实力：
输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。

注意：
2 <= piles.length <= 500
piles.length 是偶数。
1 <= piles[i] <= 500
sum(piles) 是奇数。
```

Alex 先选，两个人都会一直做最优选择，问我们最终 Alex 是否能获胜。这一题可以用动态规划来做，还有一种让人虎躯一震的做法，堪称leetcode有史以来最简单的代码。


## 动态规划

动态规划的做法，还是老规矩，动态规划三部曲：

### 开数组

由于玩家获胜的规则是拿到的石子数多，所以我们用一个二维数组，其中**dp[i][j]表示在区间[i, j]内先手拿石子，在理想策略下，可以多拿的石子数**，若为正数，说明先手拿得可以必胜，若为负数，则表示先手拿必输。

则最终只要看dp[0][n-1]的值，若为正数，则Alex先手拿能获胜。

为什么要这么定义dp数组？请接着看下文。

### 状态转移方程

假设我们现在处理的子问题是dp[i][j]，我们现在要计算这个时候先手拿能多拿的石子数。在这个区间上，先手拿的人只能拿i位置或者j位置的石子，假如先手的人拿了piles[i]的话，等于先手的人多了piles[i]个石子。这个时候，区间缩小了，变成了[i+1,j],这个时候，**另一个人变成了先手的人，问题变成了dp[i+1][j]**。假设我们已经知道了dp[i+1][j]的值，也就是此时后手（次回合先手）的人能多拿的石子个数，所以，先手的人若选择了piles[i],那么他能多拿的石子净个数为piles[i] - dp[i + 1][j].

同样的道理，如果[i,j]时先手的那个人选了j,那么他能多拿的石子净个数为piles[j] - dp[i][j - 1]。 

最后我们需要在二者中取最大值，就是此时dp[i][j]的值

```python
dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])
```

### 找初始值

始化只有i一个石头堆的情形，初始化只需要考虑有一个石头堆的情况，很简单：

```python
for i in range(n):
    dp[i][i] = piles[i]
```


## 实现

可以直接在leetcode上提交的代码：

```python
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        n = len(piles)    
        dp = [[0]*n for _ in range(n)]
        
        for i in range(n):
            dp[i][i] = piles[i]
            
        for i in range(n-1):
            for j in range(n):
                dp[i][j] = max(piles[i]-dp[i+1][j], piles[j] - dp[i][j - 1])
                
        
        return dp[0][n-1] > 0
```

以上是常规做法，老实刷题的小白专属。

## 神做法

这一题是leetcode周赛出过的一道题，最快的一位同学，也是一位著名大神，来自日本的uwi选手，只用了一分钟多一点就做出了这题。他是怎么做到的？

我们来看一下他的代码（改写成python）：

```python
def stoneGame(self, piles: List[int]) -> bool:
    return True
```

只有一行？！

是的，你没有看错！leetcode已经水到了medium难度的题目一行就能写完的地步（误）。

事实就是：先走的人一定可以必胜！

其实这道题，是一道脑筋急转弯题，我们分析一下：

因为题目给了限定条件，总和是奇数，堆的个数是偶数。我们按照奇偶分成两堆，因为总和为奇数，所以这两堆的石子总和一定不相同。那么Alex只要先手算出奇数堆里的石子多还是偶数堆里的石子多，那么一定必胜。

比如分成两堆后，偶数堆里面石子的总和比较多，Alex选择偶数，piles[0], piles[2], …, piles[n-2]，他选择了piles[0]，这个时候Lee可以选择piles[1] 或 piles[n - 1].之后Alex可以继续选择偶数的位置。所以Lee就被迫选择了所有奇数的位置。

反之，如果Alex从倒数第一个开始选，那么他能选到所有的奇数位置，Lee被迫选偶数位置。故，Alex只要选出奇数、偶数位置中求和之后最大的就行，一定会赢。

## 总结

这一题应该算是leetcode里面比较奇葩的一题了。如果做的时候能瞬间想通这个脑筋急转弯，那这题就是秒杀。如果一时半会没有想到这个，老实用动态规划做，也可以比较轻松的做出来。


## 支持

如果喜欢本文的话，欢迎关注我的微信公众号：老方刷题。谢谢您的支持！

![公众号二维码](https://pic.images.ac.cn/image/5ea28014bf1cf.html)